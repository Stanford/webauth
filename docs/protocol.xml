<?xml version="1.0"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?rfc private="WebAuth Documentation"?>
<?rfc toc="yes" symrefs="yes"?>
<rfc category="info" docName="draft-allbery-webauth-00" ipr="trust200902">
  <front>
    <title>WebAuth Technical Specification</title>
    <author initials='R.' surname='Schemers' fullname='Roland Schemers'>
      <organization>Stanford University</organization>
    </author>
    <author initials='R.' surname='Allbery' fullname='Russ Allbery'>
      <organization>Stanford University</organization>
      <address>
        <email>eagle@eyrie.org</email>
        <uri>http://www.eyrie.org/~eagle/</uri>
      </address>
    </author>
    <date month='August' year='2014' />

    <abstract>
      <t>Defines the WebAuth protocol for authenticating users to web
      applications using only the basic capabilities of a web browser.
      Authentication is handled by a central login server using a protocol
      local to the given site.  Authentication information is then passed
      to application servers via encrypted tokens in a URL and maintained
      by the browser as cookies.</t>
    </abstract>
  </front>

  <middle>
    <section anchor='intro' title='Introduction'>
      <section anchor='components' title='WebAuth Components'>
        <t>The WebAuth protocol involves interactions between three basic
        components:
          <list style='numbers'>
            <t>User-Agent (UA), the user's browser</t>
            <t>WebAuth-enabled Application Server (WAS), a web server that
               wants to serve content authenticated via WebAuth</t>
            <t>WebKDC, the login server and provider of authenticators to
               the other two components</t>
          </list>
        </t>

        <t>The WebAuth protocol allows a WAS to securely identify a user
        accessing resources.  It also supports single sign-on, allowing a
        user to access multiple WebAuth-protected applications without
        having to authenticate to each one separately (unless an
        application requires this for security reasons).</t>

        <t>The WAS can also choose to either trust the WebKDC to vouch for
        the identity of a user, or it can request the WebKDC use an
        authenticator such as a Kerberos service request (KRB_AP_REQ)
        that it can verify using its own Kerberos keys.</t>

        <section anchor='compua' title='User-Agent (UA)'>
          <t>The User-Agent is a web browser that supports cookies.  No
          plugins, Java, or JavaScript are required. The UA will be
          redirected to the WebKDC as requested to by a WAS.</t>
        </section>

        <section anchor='compwas' title='WebAuth-enabled Application
          Server (WAS)'>
          <t>A WebAuth-enabled Application Server is a web server
          configured to use WebAuth to authenticate users.  If a user
          hasn't been authenticated yet (indicated by the UA possessing
          and presenting a WAS cookie), they will be redirected to the
          WebKDC.  Otherwise, the WebAuth-established authenticated
          identity will be used for access control.</t>

          <t>All interactions between the UA and WAS SHOULD be protected
          with TLS or SSL to prevent cookies being disclosed to an
          eavesdropper that could use those cookies to impersonate a user.
          The secure flag SHOULD be set on all WAS cookies to request that
          the browser enforce this.</t>
        </section>

        <section anchor='compwkdc' title='WebKDC'>
          <t>The WebKDC will listen for two different type of requests,
          distinguished by different URLs.</t>

          <t>The first type of request are those requests coming from a UA
          after it has been redirected by a WAS.  This component of the
          WebKDC is referred to as the WebLogin service.  When the WebKDC
          receives one of these, it will first see if the request includes
          a cookie that contains cached credentials.  If the request
          contains a valid cookie, this cookie is used to obtain new
          credentials and the user is redirected back to the WAS (unless
          the WAS has requested the user reauthenticate).  This is the way
          that WebAuth implements single sign-on.</t>

          <t>If the cookie is not present or has expired, then the user
          will be prompted for their username and password.  After
          submitting this information back to the WebKDC, the WebKDC will
          then verify the username and password, using whatever protocol
          is suitable for that site (Kerberos is the default).  The WebKDC
          will the generate two "tokens".  One is placed in a cookie
          scoped for the WebKDC and used to provide single sign-on in
          future requests, and one that gets sent back to the WAS, which
          will verify it upon receipt.</t>

          <t>The second type of request the WebKDC handles consists of XML
          messages that get POSTed to the WebKDC via HTTPS directly from a
          WAS.  These messages are used to establish keys for the WAS
          servers or to request additional credentials for a user.</t>

          <t>The WebKDC is also responsible for ensuring that the server
          making a request is authorized to make the request.  For
          example, one WAS server can't use a "token" that was created for
          use by another WAS server.</t>

          <t>All interactions between the UA or WAS and the WebKDC MUST be
          protected via TLS or SSL to prevent disclosure of passwords, as
          well as sensitive data such as the tokens which are used to
          provide single sign-on and access to application resources.</t>
        </section>
      </section>

      <section anchor='tokens' title='WebAuth Tokens'>
        <t>Tokens provide a standard mechanism to exchange and store
        information that is cryptographically secure from both tampering
        and disclosure.  Tokens also contain information such as creation
        times to help detect replays, and expiration times so data is
        never trusted/used forever.  Tokens also enable authentication of
        the servers using them.</t>

        <t>Tokens get transfered between servers using URL query
        parameters, POST data, cookies, and XML documents.  They are
        AES-encrypted using either a private key, or a shared session key.
        They also include a SHA1 HMAC used to detect data modification or
        tampering.</t>

        <t>There are currently nine different types of tokens:
          <list style='hanging' hangIndent='4'>
            <t hangText='webkdc-service (encrypted with WebKDC private key)'>
            <vspace blankLines='0'/>The webkdc-service-token is used by
            WebAuth App Servers to communicate with the WebKDC.  It
            contains a session key that is shared between the WebKDC and
            the WAS.  <vspace blankLines='1' /> webkdc-service tokens are
            created only by the WebKDC, and are used only by a WAS.  From
            the perspective of the WAS, they are opaque blobs that are
            sent back to the WebKDC</t>

            <t hangText='webkdc-proxy (encrypted with WebKDC private key)'>
            <vspace blankLines='0'/>The webkdc-proxy-token contains a
            user's proxied credentials (generally, but not necessarily, a
            Kerberos ticket-granting ticket).  It can only be decrypted by
            the WebKDC, and the WebKDC will only allow a webkdc-proxy
            token to be used by the server it was originally generated
            for.  The main use of a webkdc-proxy token is by the WebKDC
            itself to implement single sign-on; that webkdc-proxy token is
            usually put in a cookie scoped to the WebLogin service.  Its
            secondary use is to allow WAS servers to request
            credential-tokens.</t>

            <t hangText='request (encrypted with session key)'>
            <vspace blankLines='0'/>The request token contains the request
            from a WAS for a token (usually an id token) from the WebKDC.
            It is AES-encrypted using a session key from a webkdc-service
            token, and contains information like the return URL and type
            of token requested.  A webkdc-service token is always included
            in a request along with a request token.</t>

            <t hangText='error (encrypted with session key)'>
            <vspace blankLines='0'/>An error token is returned by the
            WebKDC in the event of an unrecoverable error that occurred
            while asking for a token with a request token.</t>

            <t hangText='id (encrypted with session key)'>
            <vspace blankLines='0'/>An id token contains the identity of
            the user trying to access a resource.  The WAS will verify the
            id token and then will normally construct an app token for
            future use.</t>

            <t hangText='proxy (encrypted with session key)'>
            <vspace blankLines='0'/>A proxy token is used to return a
            webkdc-proxy token to a WAS.  It includes information about
            the webkdc-proxy token such as its expiration and its
            type.</t>

            <t hangText='cred (encrypted with session key)'>
            <vspace blankLines='0'/>A credential token contains a
            credential for a user (generally a Kerberos service
            ticket).</t>

            <t hangText='login (encrypted with WebKDC private key)'>
            <vspace blankLines='0'/>A login token is used by the WebKDC
            with the requestTokenRequest command.  It contains the user's
            username and password and is used to obtain the inital
            webkdc-proxy token.  It normally only used internally by the
            WebLogin component of the WebKDC.</t>

            <t hangText='app (encrypted with WAS private key)'>
            <vspace blankLines='0'/>An app token is used by a WAS server
            to store data, such as the identity of a user after it has
            been verified from an id token, a proxy token, or credentials
            for future use.</t>
          </list>
        </t>

        <t>Their exact formats are discussed in detail at the end of this
        document.</t>
      </section>

      <section anchor='keymgmt' title='Security Model and Key Management'>
        <t>As mentioned in the previous section, tokens are at the heart
        of the WebAuth security model.  They are used to authenticate
        requests and responses between servers, as well as protect data
        that is stored in URLs and cookies.  Shared symmetric keys
        (session keys) are used to encrypt tokens between servers, and
        private keys are used to encrypt tokens meant for a only a single
        server to decrypt.</t>

        <t>Also note that any tokens that appear in URLs are tokens that
        are only valid for a short period of time (5 minutes by
        default).  Any attempt to re-use them after that will fail.  If a
        user bookmarks a URL with a token in it (or hits their "back"
        button) then exactly one of these three things will happen:
          <list style='symbols'>
            <t>The user has a valid cookie. In this case, the token in the
            URL is ignored (but still stripped out from the URL before
            passing it to the app), so there is no problem.</t>

            <t>The user has no valid cookie, but the token in the URL is
            still valid.  In this case, the user will be authenticated and
            a cookie will be created.  Note that this can only happen
            until the token is no longer "fresh" (as mentioned, 5 minutes
            by default).</t>

            <t>The user has no valid cookie, and the token is too old. In
            this case, the user will be redirected to the login page is
            usual (the token will be stripped from the URL before the
            redirect).</t>
          </list>
        </t>

        <section anchor='kmsessionkeys' title='Distributing and Managing
          Session Keys'>

          <t>In order to exchange session keys, a key distribution
          protocol is needed.  For this purpose, we use Kerberos and
          TLS/SSL to bootstrap and get the session keys.  The WAS that
          needs a session key will post an XML message to the WebKDC
          requesting a service token.  This message contains a KRB_AP_REQ
          for the WebKDC's server principal, which the WebKDC uses to
          authenticate the server making the request.  The WebKDC will
          then send back two pieces of data: a session key, and a service
          token encrypted with the WebKDC's private key and containing the
          same session key.  The service token is opaque to the WebAuth
          Application Server; it just stores this token and provides it to
          the WebKDC later when making requests.</t>

          <t>This mechanism allows the WebKDC to not have to store the
          session key locally.  For subsequent requests, the WAS will
          encrypt the request in the session key and provide a copy of the
          service token alongside the request.  The WebKDC will decrypt
          the service token with its private key, recover the session key,
          and use it to decrypt and validate the request.  This means the
          WebKDC does not have to store any keys other than the private
          key that is used to encrypt the service tokens.</t>

          <t>The whole transaction itself is protected with TLS or
          SSL.</t>

          <t>There are no long term keys stored on the WebKDC itself other
          its own private key.  Once the WAS obtains the service token and
          session key, it will cache them both until the service token
          expires.  Before the service token expires, the WAS must request
          a new service token and will be given a corresponding new
          session key.</t>

          <t>The WebAuth protocol is designed so that other authentication
          mechanisms may be used to bootstrap, such as GSS-API or TLS
          client authentication between servers.  Kerberos is just the
          first implemented bootstrap authentication mechanism.</t>

          <t>One potential issue here is that potentially weaker keys
          (Kerberos keytabs, which could be 3DES or even just DES) are
          being used to bootstrap into stronger WebAuth AES keys.  This
          issue is partially mitigated by the use of TLS or SSL to further
          protect the transaction.  This seems to be an acceptable risk,
          but it's worth being aware of.  The Kerberos infrastructure
          should obviously use the strongest keys possible.</t>
        </section>

        <section anchor='kmprivatekeys' title='Distributing and Managing
          Private Keys'>

          <t>Both the WebKDC and the WAS servers need private keys to
          encrypt their tokens with.  These keys will be
          randomly-generated 128-bit AES keys (longer keys are supported
          if needed).  They are stored in key rings on the WebKDC or WAS
          server.  The key ring SHOULD support holding both currently
          valid keys and keys that will be valid in the future.</t>

          <t>Since key rings are never sent over the network by the
          WebAuth protocol, WebAuth implementations can use whatever
          mechanism they wish to store keys.  However, the following
          data should be stored for each key:
            <list style='hanging' hangIndent='4'>
              <t hangText='key type'><vspace blankLines='0'/>Type of the
              key.  AES is the only supported key type right now.</t>

              <t hangText='key data'><vspace blankLines='0'/>The binary
              data that makes up the key.</t>

              <t hangText='creation'><vspace blankLines='0'/>Time the key
              was created.</t>

              <t hangText='valid_after'><vspace blankLines='0'/>When the
              key becomes valid.</t>
            </list>
          </t>

          <t>Of note is the valid_after value.  It is used to create
          post-dated keys in the key ring, to allow for new keys to get
          generated and distributed among a pool of servers (for load
          balancing/fail-over) in such a way that all the keys can be
          updated before the key becomes valid.</t>

          <t>There is no support in the WebAuth protocol itself for
          distributing key rings among pools of servers, but a mechanism
          such as SSH can be used.</t>

          <t>Stand-alone servers (not part of a pool) SHOULD automatically
          generate new keys when needed on a restart.</t>
        </section>

        <section anchor='kmpool' title='Supporting Server Pools'>
          <t>In order to support server pools, we need to ensure that any
          server that receives a token is able to decrypt and verify
          it.  Note that we are only talking about the WebAuth protocol
          here.  Applications must solve their own synchronization issues
          when using a pool of servers as a front end.</t>

          <t>For the WebKDC, all we need to do is distribute the same key
          ring across all the WebKDCs.  Post-dating new keys when adding
          them makes this task easier, since the key ring only has to be
          updated on all WebKDCs by the time the key becomes valid.</t>

          <t>For a WAS, there are two issues.  First, we also need to
          distribute the key ring so all WAS servers can decrypt their
          app-tokens.  The second question is how to deal with session
          keys.</t>

          <t>Responses from the WebKDC come back to the WAS encrypted with
          the session key, not the WAS server's private key.  If the
          response comes back to a different WAS server, it will not have
          the same session key that the requesting WAS server had.  One
          could work around this by sharing the same service token and
          session key across all the servers, but this would be painful
          and expensive to do.</t>

          <t>The most flexible and recommended solution is for WAS servers
          to include some state (described below) in each request token.
          The WebKDC treats this state as opaque data and returns it to
          the WAS server along with the requested token.  It is
          transmitted alongside the returned token, not inside it, so that
          the WAS doesn't have to know the session key to read it.  To use
          this method, the WAS server creates an app token (which is
          encrypted with its private key, shared among all the sytsems in
          the pool), includes in it the session key, and sends this as the
          state in the request token.  Since the WebKDC returns this state
          along with its response, any WAS in the pool can then decrypt
          the state with its private key, recover the session key, and
          then use that to decrypt the rest of the response.</t>

          <t>Another somewhat simpler way to handle this is make sure that
          the return URL in the request token contains the server's
          private hostname or IP address instead of the virtual or pool
          address.  This solves the problem as the request always comes
          back to WAS server that initiated the request.  However, this
          means that the real server name or IP address must be exposed to
          the UA and transparent failover among systems in the pool will
          not be supported.</t>
        </section>
      </section>
    </section>

    <section anchor='scenarios' title='WebAuth Scenarios'>
      <t>There are five basic scenarios in the WebAuth protocol.</t>

      <section anchor='sc1' title='No Tokens (Initial Sign-On)'>
        <figure>
          <preamble>The first scenario is a user request to a
          WebAuth-protected resource without any prior WebAuth login and
          without any authentication cookies.  In other words, there is no
          app token or proxy token in the UA cookie jar.</preamble>

          <artwork><![CDATA[
  ---------------------------------------------------------------
      UA                 WAS            WebKDC
  ---------------------------------------------------------------
                         send Kerberos auth for webkdc-service token
  1.                     WAS ---------> WebKDC

                         return session key, webkdc-service token
  2.                     WAS <--------- WebKDC

      request resource
  3.  -----------------> WAS

      redirect to WebKDC w/request token asking for id token
  4.  <----------------- WAS

      pass along request token
  5.  -------------------------------> WebKDC

      login form sent back
  6.  <------------------------------- WebKDC

      post login form with user authentication (password)
  7.  -------------------------------> WebKDC

      confirmation page sent back, link contains id token
  8.  <------------------------------- WebKDC

      re-request resource (with returned id token in URL)
  9.  -----------------> WAS

      set the app token cookie, response from app
  10. <----------------- WAS

  ---------------------------------------------------------------
]]></artwork>

          <postamble>The first and second steps normally happen when the
          WAS is first started or when its previous service token expire
          and are included for completeness.  They are omitted in all
          further scenarios, but should be assumed to happen when
          needed.</postamble>
        </figure>

        <t>
          <list style='numbers'>
            <t>The WAS connects directly to the WebKDC and requests a
            service token and session key to use for further requests.  It
            includes in this request a KRB_AP_REQ for the WebKDC's service
            principal, using the WAS's private Kerberos key.</t>

            <t>The WebKDC authenticates the WAS server via Kerberos and
            returns the webkdc-service token and corresponding session
            key.</t>

            <t>The UA requests a WebAuth-protected resource from WAS.</t>

            <t>No app token is found either in a cookie or in the URL, so
            the WAS constructs a request token, asking for an id token.
            The request token also contains the return URL, requested type
            of token, and any additional desired options.  It may also
            contain an app token with the session key encrypted with the
            WAS's private key (for handling server pools).  The request
            token is encrypted with the AES session key shared between the
            WAS and the WebKDC.  The WAS then returns a temporary redirect
            to the UA, sending the UA to the WebLogin component of the
            WebKDC and including the request token in the redirect
            URL.</t>

            <t>The UA follows the redirect and sends a request to the
            WebLogin component of the WebKDC, including the request token
            in the URL.  No cookies are sent to the WebKDC since the user
            has never previously authenticated.</t>

            <t>The WebKDC decrypts the request token, checks the creation
            time to make sure the request is fresh, and sends back a login
            form or other authentication prompt to the UA.  The request
            token or needed information derived from it will generally be
            included in a hidden form field.  (This assumes that a form
            prompt is needed to authenticate the user.  If the user can be
            authenticated directly by the WebLogin server via some method
            such as SPNEGO, it may skip sending back a login form and
            therefore also skip the next step, proceeding directly to
            checking the authorization of the WAS.)</t>

            <t>The user enters their username and password or other
            authentication credentials and instructs their UA to submit
            the form back to the WebKDC.</t>

            <t>The WebKDC validates the username and password or other
            authentication credentials and also makes sure that the WAS is
            allowed to request the token asked for in the request token.
            Assuming the username and password are valid, the WebKDC
            constructs a webkdc-proxy token and the id token and then
            sends a confirmation page back to the UA which includes a link
            back to the WAS that contains the id token (and any additional
            state information sent by the WAS) in the URL.  The response
            page also sets a cookie containing the webkdc-proxy token.
            (For some forms of authentication that can be repeated without
            prompting the user, such as SPNEGO, the WebKDC may decide not
            to set a webkdc-proxy cookie.)</t>

            <t>When the user follows the link on the confirmation page,
            the UA will re-request the original resource but now with the
            id token included in the URL.</t>

            <t>The WAS will see the id token in the URL and will check to
            ensure it is fresh.  It will then look at the subject
            authenticator-type in the token to see if it needs to verify
            the subject.  If the authenticator-type is krb5, it uses its
            Kerberos keytab to verify the identity of the subject.  In
            this case, the token will include a KRB_AP_REQ for the
            Kerberos identity of the WAS in the subject authenticator data
            field of the id token.
            <vspace blankLines='1' />
            After verifying the subject if desired, the WAS creates an app
            token based on the id token and puts it into a cookie to
            authenticate future requests from that UA.  The app token will
            inherit the expiration time of the id token.  The WAS then
            passes the request to the underlying web application,
            stripping the id token from the URL before doing so and
            including the WebAuth-derived authentication information.
            When the web application returns the resource, the WAS adds a
            header to set the app token before sending that resource back
            to the UA.</t>
          </list>
        </t>

        <t>The above assumes that the WAS will use a WebAuth app token in
        a cookie for further session authentication.  An equally valid
        choice from a protocol perspective would be for the WAS to create
        its own authentication cookies and not bother with an app token.
        Whether to do this or use app tokens is a decision entirely
        internal to the WAS, but note that the metadata in the id token
        (particularly the expiration time) MUST be honored by the WAS.</t>

        <t>All cookies set by the WebAuth protocol MUST be session cookies
        that are destroyed when the browser is closed.  This allows the
        user to easily log out by closing the browser before the tokens in
        the cookies expire.</t>
      </section>

      <section anchor='sc2' title='App Token'>
        <figure>
          <preamble>In the second scenario, the user requests a
          WebAuth-protected resource and already has an app token in a
          cookie.  This will be the most common case.</preamble>

          <artwork><![CDATA[
  ---------------------------------------------------------------
      UA                 WAS            WebKDC
  ---------------------------------------------------------------
      request resource
  1.  -----------------> WAS

      response
  2.  <----------------- WAS

  ---------------------------------------------------------------
]]></artwork>
        </figure>

        <t>
          <list style='numbers'>
            <t>The UA requests a WebAuth-protected resource from WAS and
            includes a cookie containing an app token for that WAS.</t>

            <t>The WAS decrypts the app token with its private key,
            determines the user identity from the contents, and passes the
            request to the underlying application along with that
            identity.</t>
          </list>
        </t>
      </section>

      <section anchor='sc3' title='No App Token, Proxy Token (Single
          Sign-On)'>
        <figure>
          <preamble>In the third scenario, the user requests a
          WebAuth-protected resource and doesn't have an app token for
          that WAS, but does have a webkdc-proxy token (in a cookie) for
          the WebKDC.  This is the single sign-on case:  the user has not
          authenticated to that application, but has previously
          authenticated via WebAuth.  The WebKDC can use the user's
          webkdc-proxy token to authenticate the user without having to
          prompt them for their password again.</preamble>

          <artwork><![CDATA[
  ---------------------------------------------------------------
      UA                 WAS            WebKDC
  ---------------------------------------------------------------
      request resource
  1.  -----------------> WAS

      redirect to WebKDC w/request token asking for id token
  2.  <----------------- WAS

      pass along request token
  3.  -------------------------------> WebKDC

      confirmation page sent back, link contains id token
  4.  <------------------------------- WebKDC

      re-request resource (with returned id token in URL)
  5.  -----------------> WAS

      set the app token cookie, response from app
  6.  <----------------- WAS

  ---------------------------------------------------------------
]]></artwork>

          <postamble>This assumes the WAS has already established a
          session key with the WebKDC, as previously
          discussed.</postamble>
        </figure>

        <t>
          <list style='numbers'>
            <t>The UA requests a WebAuth-protected resource from the
            WAS.</t>

            <t>No app token is found either in a cookie or in the URL, so
            the WAS constructs a request token, asking for an id token.
            This is done in exactly the same way as in the first
            scenario.</t>

            <t>The UA follows the redirect and sends a request to the
            WebLogin component of the WebKDC, including the request token
            in the URL.  Included in this request is a cookie containing a
            webkdc-proxy token since the user has previously
            authenticated.</t>

            <t>The WebKDC detects and decrypts the valid webkdc-proxy
            token using its private key.  It uses it to construct a new id
            token and then generates a confirmation page containing a link
            to the return URL.  That link includes the id token, just as
            with the first scenario.</t>

            <t>When the user follows the link on the confirmation page,
            the UA will re-request the original resource but now with the
            id token included in the URL.</t>

            <t>The WAS verifies the id token, passes the request to the
            application with that identity information, and returns the
            result while setting an app token in a cookie as in the first
            scenario.</t>
          </list>
        </t>
      </section>

      <section anchor='sc4' title='No App Token, Credentials Required'>
        <figure>
          <preamble>In the fourth scenario, the user requests a
          WebAuth-protected resource that needs proxied credentials to act
          on the user's behalf.  In this case, the WAS must request a
          proxy token, which it will then use to request additional
          credentials via the XML interface.  In the below discussion, we
          assume the UA already has a webkdc-proxy cookie and the WebKDC
          can use single sign-on, but this is not required.  If there is
          no webkdc-proxy cookie, the user will be prompted for
          authentication and then everything else will proceed as
          below.</preamble>

          <artwork><![CDATA[
  ---------------------------------------------------------------
      UA                 WAS                WebKDC
  ---------------------------------------------------------------
      request resource
  1.  -----------------> WAS

      redirect to WebKDC w/request token asking for proxy token
  2.  <----------------- WAS

      pass along request token
  3.  ------------------------------------> WebKDC

      confirmation page sent back, contains proxy token
  4.  <------------------------------------ WebKDC

      re-request resource (with returned proxy token in URL)
  5.  -----------------> WAS

                             send proxy token with request
  6.                     WAS -------------> WebKDC

                             returns credential token
  7.                     WAS <------------- WebKDC

      set the app token cookie, response from app
  8.  <----------------- WAS
  ---------------------------------------------------------------
]]></artwork>

          <postamble>This assumes the WAS has already established a
          session key with the WebKDC, as previously
          discussed.</postamble>
        </figure>

        <t>
          <list style='numbers'>
            <t>The UA requests a WebAuth-protected resource from the
            WAS.</t>

            <t>The WAS sees no app token containing the required
            credentials and constructs a request token asking for a proxy
            token of the desired type.  It then returns a redirect to the
            WebLogin component of the WebKDC, including the request token
            in the URL, as previously.  The only difference is in the
            contents of the request token.</t>

            <t>The UA follows the redirect to the WebKDC, including the
            request token in the URL and the webkdc-proxy token for the
            WebKDC itself since the user had previously authenticated.</t>

            <t>The WebKDC decrypts and validates the webkdc-proxy token
            and uses it to construct a proxy token as requested by the
            WAS.  It then returns a confirmation page containing a link to
            the return URL with the proxy token embedded in the URL (along
            with any additional state information requested), as
            before.</t>

            <t>The user follows the link and the UA re-requests the
            original resource, now including the proxy token in the
            URL.</t>

            <t>The WAS decrypts and verifies the proxy token and recovers
            from it the embedded webkdc-proxy token.  It then sends an XML
            request direct to the WebKDC, including its webkdc-service
            token and the webkdc-proxy token, requesting an id token and
            whatever credential tokens it needs.</t>

            <t>The WebKDC receives the webkdc-service token and
            webkdc-proxy token, verifies that the subject of the
            webkdc-service token is permitted to use the webkdc-proxy
            token and verifies that it is allowed to request that type of
            credential token.  If everything is okay, it returns the
            requested id and credential tokens.</t>

            <t>After verifying the returned id token, the WAS will create
            an app token for further authentication.  It will also often
            create new app tokens containing the provided credentials for
            its own futher use so that it doesn't have to keep asking for
            credential tokens or store them locally.  The request is then
            passed to the web application, along with the user's identity
            and the credentials, and the result passed back to the UA
            along with the new cookies.</t>
          </list>
        </t>

        <t>Normally, the requested credential tokens will be Kerberos
        service tickets that the WAS can then use to talk to other
        services that use Kerberos authentication.  Since the webkdc-proxy
        token is generally a Kerberos TGT credential, this works together
        well and allows WebAuth to treat the UA's cookie jar as
        essentially a Kerberos ticket cache.  However, this is not
        required by the protocol and credential tokens may be any form of
        credential supported by the WAS and WebKDC.</t>

        <t>As with an id token, the WAS may choose not to put the
        credentials in an app token for subsequent use.  It may instead
        want to store them on the server tied to a session cookie or some
        other internal state-tracking mechanism.  However, the metadata in
        the credential tokens (particularly expiration time) MUST be
        honored.</t>

        <t>The credentials returned by the WebKDC in a credential token
        SHOULD encode an expiration time that cannot be manipulated by the
        WAS so that the WAS need not be trusted to honor credential
        expiration.</t>
      </section>

      <section anchor='logout' title='Logging Out'>
        <t>The only fully effective way to log out of WebAuth is to close
        the browsing session, which will cause all WebAuth cookies to be
        discarded since they all MUST be session cookies.  This is a
        weakness in the WebAuth protocol created by the use of scoped
        cookies to hold all authentication information.  Fixing it
        requires keeping additional queriable state outside of the user's
        cookies and the WAS and WebKDC keys.</t>

        <t>Logging out of an application requires removing all session
        cookies associated with a given application on a given server
        removed.  This can be achieved with a logout link available
        within the application itself that leads to a page that clears
        all the cookies.  A WebAuth WAS implementation SHOULD provide
        some simple way for an application developer to indicate that
        going to a given URL should remove all app cookies.</t>

        <t>After logging out of the application, the user can also be
        sent to a logout page on the WebKDC that removes the
        webkdc-proxy cookie used for single sign-on.  After going to
        such a page, the user will have to reauthenticate to access any
        new web application.  However, their UA will retain app cookies
        for other applications they have already used in this session
        and have not logged out of, so the user SHOULD be warned to
        close the browser to fully log out.</t>

        <t>There is a field in the app token in which the WAS may record
        a session timeout, causing the app token to become invalid if it
        is not used within a certain period of time.  The WAS may also
        request in a request token that the webkdc-proxy token be
        ignored and the user be forced to re-authenticate even if
        already authenticated.</t>
      </section>
    </section>

    <section anchor='httpconv' title='URL Formats'>
      <section anchor='redirectkdc' title='Redirects to the WebKDC'>
        <t>Each WAS will be configured with a URL to redirect a UA to when
        the user needs to be authenticated.  When making an authentication
        request, the WAS must include both the request token and the
        webkdc-service token (the latter so that the WebKDC can decrypt
        the request token).  These tokens will be passed via query
        parameters in the URL.</t>

        <figure>
          <preamble>The format is:</preamble>
          <artwork>
  https://{host}/{webkdc-uri}?RT={request-token};ST={service-token}
          </artwork>

          <postamble>where RT is the base64-encoded request token and ST
          is the base64-encoded service token.</postamble>
        </figure>
      </section>

      <section anchor='redirectwas' title='Redirects to the WAS'>
        <t>When the WebKDC sends the UA back to the WAS with an id or
        proxy token, it will construct a return URL by taking the
        return-url specified in the request token and appending
        "?WEBAUTHR={token};" to it, where {token} is the requested token.
        If the "as" (application state) attribute was specified in the
        request token, it is base64-encoded and then appended to the URL
        (always after WEBAUTHR) as "WEBAUTHS={state};" where {state} is
        the application state provided in the request token.</t>

        <figure>
          <preamble>To be precise, the format is:</preamble>
          <artwork>
  {return-url}?WEBAUTHR={token}[;WEBAUTHS={state};]
          </artwork>

          <postamble>where the part in [] is optional.</postamble>
        </figure>

        <t>The WAS will generally strip the added components off the URL
        before passing the request to the underlying web application.  It
        may verify the token, construct an app token, and return a
        redirect to the same URL with the WebAuth data stripped and the
        cookie set rather than immediately passing the request to the
        application, to "clean up" the URL in the UA, avoid embedding
        outdated tokens in bookmarks, and confusing applications that are
        aware of their own URLs.</t>
      </section>
    </section>

    <section anchor='xmlproto' title='WebKDC XML Protocol'>
      <t>This section describes the XML protocol used to talk to the
      WebKDC.  It is used by a WAS to request a webkdc-service token and
      session key or to use a proxy token to request credential tokens,
      and internally by the WebLogin component of the WebKDC to request
      webkdc-proxy, id, and proxy tokens from the WebKDC to return to the
      UA.</t>

      <section anchor='xmlover' title='XML Protocol Overview'>
        <t>The protocol consists of an exchange of XML-formatted messages
        over an HTTPS connection.  A protocol interaction consists of a
        single XML message sent by the client with HTTP POST and a single
        XML message response from the server.</t>

        <t>For ease of parsing, for any elements that require a
        base64-encoded value, there must be no whitespace after the open
        element and before the close element.</t>

        <figure>
          <preamble>For example, this is valid:</preamble>
          <artwork><![CDATA[
  <requestToken>{base64-webkdc-service-token}</requestToken>
]]></artwork>
        </figure>

        <figure>
          <preamble>while this is not:</preamble>
          <artwork><![CDATA[
  <requestToken>
      {base64-webkdc-service-token}
  </requestToken>
]]></artwork>
        </figure>

        <t>The spec uses whitespace in the following examples for
        readability, but bearing in mind the above, it should be omitted
        in practice.</t>

        <figure>
          <preamble>The command request format is:</preamble>
          <artwork><![CDATA[
  <xxxxRequest>
    <!-- rest depends on command -->
  </xxxxRequest>
]]></artwork>
          <postamble>where xxxx is the type of request.</postamble>
        </figure>

        <figure>
          <preamble>The command response format on success is:</preamble>
          <artwork><![CDATA[
  <xxxxResponse>
    <!-- rest depends on command -->
  </xxxxResponse>
]]></artwork>
          <postamble>where xxxx is the type of request being responded
          to.</postamble>
        </figure>

        <figure>
          <preamble>The command response format on failure is:</preamble>
          <artwork><![CDATA[
  <errorResponse>
    <errorCode>{numeric}<errorCode>
    <errorMessage>{message}<errorMessage>
  </errorResponse>
]]></artwork>
        </figure>
      </section>

      <section anchor='xmlcommon' title='Common XML Elements'>
        <t>The following elements are common to all commands.</t>

        <section anchor='xmlerrorcode' title='&lt;errorCode&gt;'>
          <t>This is a numeric error code for an errorResponse message.
          It MUST be one of the following:
            <list style='hanging' hangIndent='4'>
              <t hangText='1'>The service token used was expired.</t>

              <t hangText='2'>The service token used was corrupt and/or
              was unable to be decrypted.</t>

              <t hangText='3'>The proxy token used was expired.</t>

              <t hangText='4'>The proxy token used was corrupt and/or was
              unable to be decrypted.</t>

              <t hangText='5'>The request was invalid.  For example, a
              required element was missing, an attribute value was
              incorrect, the server was unable to parse the XML request,
              etc.  This generally indicates a bug in the client.</t>

              <t hangText='6'>The request was unauthorized.  An attempt
              was made to request a token type that the client was not
              authorized to request.</t>

              <t hangText='7'>The server encountered an internal error
              (out of memory, for example).  If the client retries the
              request may succeed, though some external event might be
              causing the problem (such as a Kerberos server being
              down).</t>

              <t hangText='8'>The request token was stale.</t>

              <t hangText='9'>The request token was invalid.</t>

              <t hangText='10'>Unable to obtain the requested credential
              token.</t>

              <t hangText='11'>The krb5 &lt;requesterCredential> was
              bad.</t>

              <t hangText='12'>The login token was stale.</t>

              <t hangText='13'>The login token was invalid.</t>

              <t hangText='14'>Login failed due to bad password, invalid
              username, invalid OTP code, or some other authentication
              failure.</t>

              <t hangText='15'>A webkdc-proxy token of a certain type was
              required to fulfill the request but was not present in the
              request.</t>

              <t hangText='16'>The user selected cancel during the login
              process.</t>

              <t hangText='17'>The WAS server requested a forced login in
              the request token, so obtaining the id or proxy token via
              the webkdc-proxy token is not allowed.</t>

              <t hangText='18'>The user's principal was not permitted to
              authenticate to the WebKDC.</t>

              <t hangText='19'>The user's password has expired.</t>

              <t hangText='20'>The WAS server requested multifactor
              authentication, so obtaining the id or proxy token via only
              a webkdc-proxy token or only a login token is not
              allowed.</t>

              <t hangText='21'>The WAS server requested multifactor
              authentication, but this user is not capable of multifactor
              authentication for some reason (such as not being known to
              the underlying multifactor authentication system or not
              having a strong enough second factor configured).</t>

              <t hangText='22'>The user is not permitted to log in at this
              time for security reasons.  This may be due to such factors
              as the originating IP address.  This code indicates a
              temporary failure, not incorrect credentials (which is
              indicated by error code 14).  Compare to error code 24.</t>

              <t hangText='23'>The WAS server requested a Level of
              Assurance in the authentication that cannot be obtained for
              this user (perhaps because the user doesn't have a strong
              enough authentication method configured or hasn't associated
              the account with proof of identity).</t>

              <t hangText='24'>The user is not permitted to authenticate
              to the desired destination WAS at this time.  This may be
              due to local policy, security limitations placed on the
              user, missing prerequisite actions that the user must take
              (such as training or a usage agreement), or some other local
              factor.  This code indicates that this specific
              authentication is not allowed but another authentication by
              the same user from the same host to a different site may be
              permitted.  Error code 22 indicates that this user may not
              authenticate at this time from that host, regardless of
              their destination.</t>

              <t hangText='25'>This authentication appears to be a
              replay.</t>

              <t hangText='26'>This authentication was rejected due to too
              many failed authentication attempts for this user.  The
              authentication should be retried later.</t>

              <t hangText='27'>This authentication failed due to a remctl
              timeout.  The authentication should be tried again.</t>
            </list>
          </t>
        </section>

        <section anchor='xmlerrmsg' title='&lt;errorMessage&gt;'>
          <t>This is a textual description of the error code, meant to be
          human readable but not ideal for displaying to the user (it is
          not localized).  It's useful for log messages or for
          localization of last resort.</t>
        </section>
      </section>

      <section anchor='xmlcmd' title='XML Commands'>
        <t>There are currently four commands defined: getTokens,
        requestToken, webkdcProxyToken, and webkdcProxyTokenInfo.  The
        getTokens command is used directly by the WAS to request either a
        service token or id and credential tokens from a proxy token.  The
        requestToken command is used by the WebLogin component of the
        WebKDC to process a request token sent in a URL from a WAS.  The
        webkdcProxyToken command converts an existing credential (such as
        a Kerberos credential for the ticket-granting service) into a
        webkdc-proxy token and can be used to bootstrap WebAuth
        authentication from an existing Kerberos ticket cache for improved
        single sign-on.  The webkdcProxyTokenInfo command returns
        information about an existing webkdc-proxy token.</t>

        <section anchor='xmlgettokens' title='getTokens'>
          <t>The getTokens command is used to request tokens (service, id,
          proxy, or credential).  It is used in two fundamentally
          different ways: for a WebAuth Application Server to request a
          webkdc-service token from the WebKDC, and for a WAS to use a
          proxy token it acquired from the user to request cred or id
          tokens.</t>

          <figure>
            <preamble>
              The request message for obtaining a service token is:
            </preamble>
            <artwork><![CDATA[
  <getTokensRequest>
    <requesterCredential type="krb5">
       {base64-krb5-mk-req-data}
    </requesterCredential>

    <tokens>
      <token type="service" id="{id-for-response}"/>
    </tokens>
  </getTokensRequest>
]]></artwork>
          </figure>

          <figure>
            <preamble>The response message is:</preamble>
            <artwork><![CDATA[
  <getTokensResponse>
    <tokens>
      <token id="{id-from-request}">
        <tokenData>{base64}</tokenData>
        <sessionKey>{base64-session-key}</sessionKey>
        <expires>{expiration-time}</expires>
      </token>
    </tokens>
  </getTokensResponse>
]]></artwork>
          </figure>

          <t>The id attribute to the &lt;token> element in the request is
          optional and is normally omitted, since the WAS is only
          requesting one token.  If it is omitted in the request, it is
          also omitted in the response.</t>

          <t>If any errors occur, an &lt;errorResponse> message will be
          returned instead.</t>

          <t>The second form of this request is used by the WAS to obtain
          additional credentials from a proxy token.  This is used when
          the WAS may need Kerberos credentials on behalf of the user, and
          therefore requested a proxy token instead of an id token in the
          original authentication request to the WebKDC.  The
          &lt;getTokensRequest> request message is used to obtain those
          cred tokens plus an id token.</t>

          <t>requesterCredentials of type "krb5" can only be used to obtain
          a webkdc-service token.  They can't be used for obtaining any
          other tokens, nor can a credential of type "service" be used to
          request another webkdc-service token.  In all other cases, the
          requesterCredentials are a webkdc-service token.</t>

          <figure>
            <preamble>
              The request message for obtaining other tokens from a proxy
              token is:
            </preamble>
            <artwork><![CDATA[
  <getTokensRequest>
    <requesterCredential type="service">
       {base64-webkdc-service-token}
    </requesterCredential>

    <subjectCredential type="proxy">
       <proxyToken>{base64-webkdc-proxy-token}</proxyToken>
       <!-- additional <proxyToken>...</proxyToken> here -->
    </subjectCredential>

    <requestToken>{base64-request-token}</requestToken>

    <tokens>
      <token type="id|cred" id="{id-for-response}">
        <!-- for type="id" -->
        <!-- optional, default is krb5 -->
        <authenticator type="krb5|webkdc"/>

        <!-- for type="cred" -->
        <credentialType>krb5</credentialType>
        <serverPrincipal>{krb5-service}</serverPrincipal>
      </token>
      <!-- additional <token>...</token> requests go here -->
    </tokens>
  </getTokensRequest>
]]></artwork>
          </figure>

          <figure>
            <preamble>The response message is:</preamble>
            <artwork><![CDATA[
  <getTokensResponse>
    <tokens>
      <token id="{id-from-request}">
        <tokenData>{base64}</tokenData>
      </token>
      <!-- additional <token>...</token> responses go here -->
    </tokens>
  </getTokensResponse>
]]></artwork>
          </figure>

          <t>Here, the credentials provided are a previously-requested
          webkdc-service token instead of a Kerberos authenticator, and
          the proxy token received from the user's browser is also
          included.  In this form of the request, the WAS also includes a
          request token, encrypted with the session key of the
          webkdc-service token, to prove that it has possession of the
          session key.</t>

          <t>If any errors occur, an &lt;errorResponse> message will be
          returned instead.</t>
        </section>

        <section anchor='xmlrequesttoken' title='requestToken'>
          <t>The requestToken command is used by the WebLogin component of
          the WebKDC to process a request token sent in a URL from a
          WAS.</t>

          <figure>
            <preamble>The request message is:</preamble>
            <artwork><![CDATA[
  <requestTokenRequest>

    <requesterCredential type="service">
      {base64-webkdc-service-token}
    </requesterCredential>

    <subjectCredential>
      <!-- need to pass in all the existing proxy-tokens, since
           we (the web front-end) don't know which we might need -->
      <!-- source is the source of this proxy token, used to
           determine the session factors, expressed as a factor
           code, so "c" for tokens from cookies, "k" for tokens
           derived from Kerberos authentication, and so forth -->
      <proxyToken type="krb5|..." source="{factor}">...</proxyToken>
      <!-- additional <proxyToken>...</proxyToken> here -->

      <!-- present if the user just authenticated -->
      <loginToken>...</loginToken>

      <!-- a webkdc-factor token presented by the user -->
      <factorToken>...</factorToken>
    </subjectCredential>

    <!-- request token from WAS -->
    <requestToken>{base64-request-token}</requestToken>

    <!-- requested authorization identity (optional) -->
    <authzSubject>...</authzSubject>

    <!-- opaque state object for customization (optional) -->
    <loginState>...</loginState>

    <!-- request info from front-end, for logging purposes -->
    <requestInfo>
      <remoteUser>xxxx</remoteUser>

      <!-- if one of these is provided, all must be -->
      <localIpAddr>n.n.n.n</localIpAddr>
      <localIpPort>nnnn</localIpPort>
      <remoteIpAddr>n.n.n.n</remoteIpAddr>
      <remoteIpPort>nnnn</remoteIport>
    </requestInfo>
  </requestTokenRequest>
]]></artwork>
          </figure>

          <figure>
            <preamble>The response message is:</preamble>
            <artwork><![CDATA[
  <requestTokenResponse>

    <!-- loginErrorCode will be set in a requestTokenResponse if
         there was an error related to logging in  -->
    <loginErrorCode>{numeric}<loginErrorCode>
    <loginErrorMessage>{message}<loginErrorMessage>

    <!-- userMessage will be set if the User Information Service or
         OTP Validation service sets a user-message in a response,
         or if loginErrorCode is 24.  It is an HTML message intended
         for the end user.  It will normally be in a CDATA block to
         protect markup. -->
    <userMessage>{message}</userMessage>

    <!-- set in combination with a loginErrorCode of 19 if
         multifactor authentication is required -->
    <multifactorRequired>
      <factor>{factor-code}</factor>
      <!-- repeat for each factor code required by the WAS -->

      <!-- present if user has configured a multifactor method -->
      <configuredFactor>{factor-code}</configuredFactor>
      <!-- repeat for each possible authentication method available
           for that user that would satisfy a requirement of the WAS
           or site policy, omitting "m" -->

      <!-- present if there is a default second factor -->
      <defaultFactor>
        <id>{device-id}</id>
        <factor>{factor-code}</factor>
      </defaultFactor>

      <!-- lists configured ways of providing a second factor -->
      <!-- name is intended for display to the user in a list -->
      <!-- id is included in login token as device_id -->
      <!-- there may be multiple factors per device -->
      <devices>
        <device>
          <name>{device-name}</name>
          <id>{device-id}</id>
          <factor>{factor-code}</factor>
          <factor>{factor-code}</factor>
        </device>
      </devices>
    </multifactorRequired>

    <!-- any updated/new proxy tokens created -->
    <proxyTokens>
      <proxyToken type="krb5|...">{base64-proxy-token}</proxyToken>
    </proxyTokens>

    <!-- currently, only one factor token is permitted -->
    <factorTokens>
      <factorToken expires="{expiration-time}">
        {base64-factor-token}
      </factorToken>
    </factorTokens>

    <!-- the url to return to the user to -->
    <returnUrl>...</returnUrl>

    <!-- subject inside of service-token used to make request -->
    <requesterSubject>...</requesterSubject>

    <!-- subject from subjectCredential -->
    <subject>...</subject>

    <!-- authorization identity if requested and permitted -->
    <authzSubject>...</authzSubject>

    <!-- opaque state object for customization (optional) -->
    <loginState>...</loginState>

    <!-- permitted authorization identities if this user may assert
         an authorization identity to this destination -->
    <permittedAuthzSubjects>
      <authzSubject>...</authzSubject>
      <!-- repeat for all permitted authorization identities -->
    </permittedAuthzSubjects>

    <!-- requestedToken will either be an error, id, or proxy token.
         not set if <loginErrorCode> is set. -->
    <requestedToken>{base64-token}</requestedToken>

    <!-- requestedTokenType will be the type of requestedToken,
         one of error, id, or proxy.  not set if <LoginErrorCode> is
         set. -->
    <requestedTokenType>error|id|proxy</requestedToken>

    <!-- set if request token request options has "lc" -->
    <loginCanceledToken>{base64-error-token}</loginCanceledToken>

    <!-- app state is the opaque app state passed in the
         request token that we hand back to WAS -->
    <appState>{base64-state}</appState>

    <!-- optional, included if the user's login history should be
         displayed (if, for example, it was suspicious) -->
    <loginHistory>
      <!-- the name and timestamp information is optional -->
      <loginLocation name="{hostname}" time="{timestamp}">
        {ip-address}
      </loginLocation>
      <!-- repeat for site-defined length of login history -->
    </loginHistory>

    <!-- optional, included the WebKDC has information about when
         the user's password expires, in seconds since POSIX
         epoch -->
    <passwordExpires>{expiration-time}</passwordExpires>
  </requestTokenResponse>
]]></artwork>
          </figure>

          <t>If any non-login-related errors occur, an &lt;errorResponse>
          message will be returned instead.</t>

          <t>If a login-related error occurs then a
          &lt;requestTokenResponse> will be returned, but
          &lt;requestedToken> will be unset, and &lt;loginErrorCode> will
          be set.  The error codes used by &lt;loginErrorCode> are a
          subset of those used by &lt;errorCode>:
            <list style='hanging' hangIndent='4'>
              <t hangText='14'>Login failed due to bad password, invalid
              username, invalid OTP code, or similar error.  The web
              front-end should re-prompt for the username and password or
              OTP code.</t>

              <t hangText='15'>A webkdc-proxy token of a certain type was
              required and was not present in the request.  The web
              front-end should prompt for the username and password.  This
              error code may occur when two different strengths of
              webkdc-proxy tokens are used, one that's good only for id
              tokens (but may be possible to generate without prompting
              the user) and one that can generate proxy tokens.  If the
              WAS requests a proxy token and the webkdc-proxy token
              available is only good for id tokens and cannot be used to
              generate proxy tokens, this error code is returned,
              prompting the front-end to do stronger authentication.</t>

              <t hangText='17'>The WAS server requested a forced login.
              The web front-end should prompt for the username and
              password even though a webkdc-proxy token is available.</t>

              <t hangText='18'>The user's principal was not permitted to
              authenticate to the WebKDC.  The web front-end may re-prompt
              for another username and password or just display an
              error.</t>

              <t hangText='19'>The user's password has expired.  The web
              front-end may prompt the user to change it and then
              reattempt authentication.</t>

              <t hangText='20'>The WAS server requested multifactor
              authentication.  The web front-end should prompt the user
              for their second factor based on the
              &lt;multifactorRequired> attribute and then attempt
              authentication again, including any returned proxy tokens
              from this attempt.</t>

              <t hangText='21'>The WAS server requested multifactor
              authentication, but this user is not capable of multifactor
              authentication for some reason (such as not being known to
              the underlying multifactor authentication system or not
              having a strong enough second factor configured).  The web
              front end should display an error page explaining that the
              user cannot authenticate to this site without configuring
              multifactor.  The required second factor options will be
              given in the &lt;multifactorRequired> attribute.</t>

              <t hangText='22'>The user is not permitted to log in at this
              time for security reasons.  This may be due to such factors
              as the originating IP address or repeated login failures.
              The web front-end should display an error message to the
              user.</t>

              <t hangText='23'>The WAS server requested a Level of
              Assurance in the authentication that cannot be obtained for
              this user (perhaps because the user doesn't have a strong
              enough authentication method configured or hasn't associated
              the account with proof of identity).  The web front-end
              should display an error message to the user.</t>

              <t hangText='24'>The user is not permitted to authenticate
              to the desired destination WAS at this time.  This may be
              due to local policy, security limitations placed on the
              user, missing prerequisite actions that the user must take
              (such as training or a usage agreement), or some other local
              factor.  An HTML message intended for the end user will be
              present in the &lt;userMessage&gt; element of the WebKDC
              reply.</t>
            </list>
          </t>

          <t>requestedTokenType is included so that the WebLogin component
          can make display decisions based on whether the remote site
          requested an id token or a proxy token.</t>

          <t>If the request option attribute in the request token has "lc"
          in it, then &lt;loginCanceledToken> will be returned.  This
          token should be returned to the WAS if the user elects to cancel
          authentication so that the application can take appropriate
          action.  Note that it is up to the WebLogin component to send
          back that token as the requested token (WEBAUTHR in the return
          URL) if the user hits the cancel button.</t>

          <t>If the request option attribute in the request token has "fa"
          in it and a login token is not provided, this command will
          return a &lt;loginErrorCode> of 17, which indicates that the
          user is being forced to log in. Any passed-in webkdc-proxy
          tokens are ignored.</t>

          <t>The &lt;requestInfo> data is provided only for logging and
          audit purposes and MUST NOT be used for authentication.</t>
        </section>

        <section anchor='xmlwebkdcproxytoken' title='webkdcProxyToken'>
          <t>The webkdcProxyToken command is used to convert an existing
          credential, such as a Kerberos TGT credential, into a
          webkdc-proxy token.  It can be used to bootstrap WebAuth
          authentication from an existing Kerberos ticket cache for
          improved single sign-on.</t>

          <figure>
            <preamble>The request message is:</preamble>
            <artwork><![CDATA[
  <webkdcProxyTokenRequest>
    <subjectCredential type="krb5">
      <!-- for type="krb5" -->
      {base64-krb5-mk-req-data}
    </subjectCredential>

    <proxyData>
      <!-- for subjectCredential type="krb5" -->
      {base64-krb5-mk-priv-on-tgt}
    </proxyData>
  </webkdcProxyTokenRequest>
]]></artwork>
          </figure>

          <figure>
            <preamble>The response message is:</preamble>
            <artwork><![CDATA[
  <webkdcProxyTokenResponse>
    <webkdcProxyToken>{base64-proxy-token}</webkdcProxyToken>

    <!-- subject from subjectCredential -->
    <subject>...</subject>
  </webkdcProxyTokenResponse>
]]></artwork>
          </figure>

          <t>If any errors occur, an &lt;errorResponse> message will be
          returned instead.</t>
        </section>

        <section anchor='xmlwebkdcproxyinfo' title='webkdcProxyTokenInfo'>
          <t>The webkdcProxyTokenInfo command is used to get information
          about an existing webkdc-proxy-token.</t>

          <figure>
            <preamble>The request message is:</preamble>
            <artwork><![CDATA[
  <webkdcProxyTokenInfoRequest>
    <webkdcProxyToken>{base64-proxy-token}</webkdcProxyToken>
  </webkdcProxyTokenInfoRequest>
]]></artwork>
          </figure>

          <figure>
            <preamble>the response message is:</preamble>
            <artwork><![CDATA[
  <webkdcProxyTokenInfoResponse>
    <subject>...</subject>
    <proxyType>...</proxyType>
    <creationTime>...</creationTime>
    <expirationTime>...</expirationTime>
  </webkdcProxyTokenInfoResponse>
]]></artwork>
          </figure>

          <t>If any errors occur, an &lt;errorResponse> message will be
          returned instead.</t>
        </section>
      </section>

      <section anchor='xmlpost' title='Posting XML to the WebKDC'>
        <t>The XML data should be sent via POST to the WebKDC's URL, which
        should be different than the URL of the WebLogin service but
        should be on the same system.  By convention, it is normally
        /webkdc-service/ on the designated WebKDC system, but this SHOULD
        be configurable in any WebAuth implementation.</t>

        <t>The Content-Type of the POST data MUST be text/xml.</t>

        <t>This URL MUST use the HTTPS protocol, as sensitive data is sent
        without additional encryption.</t>
      </section>

      <section anchor='xmlex' title='XML Examples'>
        <section title='WAS Asking for webkdc-service Token'>
          <t>In this example, the WAS requests a webkdc-service token and
          associated session key for itself.  Such a request is sent when
          the WAS needs to send requests to the WebKDC and doesn't have a
          non-expired webkdc-service token cached.  The WAS will cache the
          token and the corresponding session key until it nears
          expiration time, at which point it SHOULD request a new one.</t>

          <figure>
            <preamble>The request:</preamble>
            <artwork><![CDATA[
  <getTokensRequest>
     <requesterCredential type="krb5">
        {base64-krb5-mk-req-data}
     </requesterCredential>
     <tokens>
       <token type="service"/>
     </tokens>
  </getTokensRequest>
]]></artwork>
          </figure>

          <figure>
            <preamble>The response:</preamble>
            <artwork><![CDATA[
  <getTokensResponse>
    <tokens>
      <token>
        <sessionKey>{base64-session-key}</sessionKey>
        <expires>{expiration-time}</expires>
        <tokenData>{base64}</tokenData>
      </token>
    </tokens>
  </getTokensResponse>
]]></artwork>
          </figure>
        </section>

        <section title='WAS Asking for a credential Token'>
          <t>In this example, the WAS requests an Kerberos ticket using a
          previously obtained webkdc-proxy token (presumably obtained from
          the UA via a redirect to the WebKDC with a request token).  The
          webkdc-proxy token's type MUST match the requested credential's
          type.</t>

          <figure>
            <preamble>The request:</preamble>
            <artwork><![CDATA[
  <getTokensRequest>
    <requesterCredential type="service">
      {base64-webkdc-service-token}
    </requesterCredential>

    <requestToken>{base64-request-token}</requestToken>

    <subjectCredential type="proxy">
      {webkdc-proxy-token}
    </subjectCredential>
    <tokens>
      <token type="credential" id="0"/>
        <credentialType>krb5</credentialType>
        <serverPrincipal>service/ldap@stanford.edu</serverPrincipal>
      </token>
    </tokens>
  </getTokensRequest>
]]></artwork>
          </figure>

          <figure>
            <preamble>The response:</preamble>
            <artwork><![CDATA[
  <getTokensResponse>
    <tokens>
      <token id="0">
        <tokenData>{base64}</tokenData>
      </token>
    </tokens>
  </getTokensResponse>
]]></artwork>
          </figure>

          <t>The WebKDC will verify that the webkdc-proxy token was
          granted to the same server identified by the request token.</t>
        </section>
      </section>
    </section>

    <section anchor='tokenformat' title='Token Format'>
      <section anchor='tokenencoding' title='Token Encoding'>
        <figure>
          <preamble>All encrypted tokens have the following general
          encoding:</preamble>

          <artwork>
  {key-hint}{nonce}{hmac}{token-attributes}{padding}
          </artwork>
        </figure>

        <t>Everything except {key-hint} is encrypted using 128-bit AES in
        CBC mode with an all-zero IV.</t>

        <t>{key-hint} is a four-byte Unix UTC time stored in network byte
        order.  It is not encrypted and is used only as a hint for the
        server to determine which key to use to decrypt the token.  It
        MUST NOT be used for any other purpose as its value is not
        protected from modification.</t>

        <t>{nonce} is 16 random bytes and is encrypted with the rest of
        the data in the token.  It is used to ensure that two tokens with
        the same data and same encryption key don't encrypt to the same
        value.  All WebAuth protocol keys MUST be rotated frequently
        enough to ensure that the chances of a nonce collision between two
        tokens encrypted with the same key are sufficiently low to be
        ignorable, since reuse of the nonce may expose similarities in the
        plaintext.</t>

        <t>{hmac} is the SHA-1 HMAC of the actual data including the
        padding (in other words, the pre-encryption concatenation of
        {token-attributes} and {padding}).  The key used with HMAC is the
        AES private key.  (A better solution would be to use a different
        key, but that requires having two keys or using a key-derivation
        function to derive the HMAC key from the AES key.  One possible
        future approach would be to use a key-derivation function like TLS
        uses.)</t>

        <t>{token-attributes} is a sequence of name=value pairs, separated
        by a ';' character.  Names must be one or more ASCII alphanumeric
        characters.  Values MAY contain arbitrary binary data, but MUST
        escape any ';' in the data by adding an additional ';' before
        it.</t>

        <figure>
          <preamble>For example, if we had the following names and
          values:</preamble>

          <artwork>
  a=1
  msg=hello;there
  bin={binarydata}
  b=2
          </artwork>
        </figure>

        <figure>
          <preamble>They would be encoded as:</preamble>
          <artwork>
  a=1;msg=hello;;there;bin={binarydata};b=2;
          </artwork>
        </figure>

        <t>{padding} is any padding of the data required to make the
        length a multiple of 16 bytes for AES encryption.  There is always
        padding present.  If the length is already a multiple of 16 bytes,
        16 bytes of padding will be added.  The value of each padding byte
        MUST be equal to the length of the padding.  For example, if the
        padding length is 7, each byte in the padding must be equal to
        0x07.</t>

        <t>The whole token is base64-encoded before being used in XML
        data, a cookie, or a query parameter.</t>
      </section>

      <section anchor='tokenattrs' title='Assigned Token Attributes'>
        <t>The following is an exhaustive list of the attribute names used
        in tokens.  All time values are 32-bit values stored in network
        byte order and are the number of seconds since 1970-01-01 00:00:00
        UTC.  All binary integers are 32-bit values in network byte order.
          <list style='hanging' hangIndent='4'>
            <t hangText='as (binary)'>
            <vspace blankLines='0'/>Optional data included in the request
            token.  If present, the same data will be sent back to the WAS
            as a second parameter to the URL, not included in the
            encrypted response token.</t>

            <t hangText='cmd (string)'>
            <vspace blankLines='0'/>The name of the XML command being
            executed (for example, getTokensRequest).  Included in the
            request token sent for XML commands.</t>

            <t hangText='crd (binary)'>
            <vspace blankLines='0'/>Credential data (for example, an
            encoded Kerberos service ticket).</t>

            <t hangText='crs (string)'>
            <vspace blankLines='0'/>The identity of the service credential
            data can be used to access (normally the text representation
            of the server principal for a Kerberos service ticket).</t>

            <t hangText='crt (string)'>
            <vspace blankLines='0'/>Credential type.  Currently this is
            always krb5.</t>

            <t hangText='ct (binary time)'>
            <vspace blankLines='0'/>Creation time of the token.  For tokens
            used to exchange messages between servers (request, error, id,
            proxy, credential), this value is used to ensure that the
            request is fresh.  For example, tokens of this type with a ct
            older then 5 minutes will get flagged by the server (WAS or
            WebKDC) as being stale.</t>

            <t hangText='did (string)'>
            <vspace blankLines='0'/>A unique device ID corresponding to
            this authentication request, and matching the device attribute
            of a &lt;configuredFactor> element in a
            &lt;requestTokenResponse> reply.  Included in a login token to
            tell the WebKDC which authentication device the user
            chose.</t>

            <t hangText='ec (string)'>
            <vspace blankLines='0'/>Error code from the WebKDC.  This will
            be the ASCII digit representation of one of the error codes
            that are returned in XML messages.</t>

            <t hangText='em (string)'>
            <vspace blankLines='0'/>Error message from the WebKDC.  This
            should only be used for logging and/or debugging, since it is
            not localized and not in a format meant for end-user
            consumption.</t>

            <t hangText='et (binary time)'>
            <vspace blankLines='0'/>Expiration time of the token.</t>

            <t hangText='ia (string)'>
            <vspace blankLines='0'/>The list of authentication factors
            used by the authenticated user to get initial credentials from
            the local authentication system, or the initial authentication
            factors that are required by this WAS for a successful
            authentication.  This is a list of factor codes separated by
            commas.  For the list of registered factor names, see <xref
            target='factors' />.</t>

            <t hangText='k (binary)'>
            <vspace blankLines='0'/>AES session key.</t>

            <t hangText='loa (binary unsigned integer)'>
            <vspace blankLines='0'/>A non-zero site-defined numeric Level
            of Assurance code for the assurance level of this
            authentication of this user, or the assurance level required
            for a successful authentication to this site.  Higher values
            indicate a stronger level of assurance; otherwise, the meaning
            of the codes is site-defined.  The value of 0 is reserved to
            indicate that no level of assurance has been determined, and
            will not appear in tokens.</t>

            <t hangText='lt (binary time)'>
            <vspace blankLines='0'/>Last-used time.  If this attribute is
            set in an app token present in a cookie, the WAS SHOULD
            periodically update it (by setting a new cookie with an
            updated last-used time) as it is used for access.  This
            attribute is used to implement timing out of unused but still
            unexpired app tokens.</t>

            <t hangText='otp (string)'>
            <vspace blankLines='0'/>User's one-time password code, in a
            login token.</t>

            <t hangText='ott (string)'>
            <vspace blankLines='0'/>The type of OTP that the one-time
            password code (in the otp attribute) is for.  This should be
            an authentication factor, generally one of the oN factors.</t>

            <t hangText='p (string)'>
            <vspace blankLines='0'/>User's password, in a login token.</t>

            <t hangText='pd (binary)'>
            <vspace blankLines='0'/>Proxy data, such as an encoded
            Kerberos credential for the ticket-granting service (a
            Kerberos TGT plus its supporting data such as the session
            key).</t>

            <t hangText='ps (string)'>
            <vspace blankLines='0'/>Proxy subject, the subject from the
            webkdc-service token that was used when the webkdc-proxy token
            was created.  This is used to verify that a webkdc-proxy token
            is being used by the same entity as originally requested
            it.</t>

            <t hangText='pt (string)'>
            <vspace blankLines='0'/>Proxy type (such as krb5).</t>

            <t hangText='ro (string)'>
            <vspace blankLines='0'/>Comma-separated list of request
            options.  Currently, the following options are supported:  lc,
            to return an error code to the application if login is
            cancelled; and fa, to force interactive authentication even if
            the user has a webkdc-proxy token.</t>

            <t hangText='rtt (string)'>
            <vspace blankLines='0'/>Requested token type in a request
            token.  This is either id for an id token or proxy for a proxy
            token.</t>

            <t hangText='ru (string)'>
            <vspace blankLines='0'/>Return URL.  The user to return the
            user to after authentication.</t>

            <t hangText='s (string)'>
            <vspace blankLines='0'/>The authenticated subject.  In
            webkdc-service tokens, this is the server identity that
            authenticated to get the webkdc-service token.  In all other
            tokens, it is the user who authenticated.  Server subjects in
            webkdc-service tokens (and only those, not other subjects)
            have the form "type:identifier".  Currently, the only defined
            type is "krb5" indicating that the server authenticated with
            Kerberos, and in that case the identifier is the text form of
            a fully qualified Kerberos principal.</t>

            <t hangText='sa (string)'>
            <vspace blankLines='0'/>Subject authenticator type in an id
            token.  This is currently either krb5, indicating that a
            Kerberos authenticator is included, or webkdc, indicating
            no additional authenticator is provided.</t>

            <t hangText='sad (binary)'>
            <vspace blankLines='0'/>Subject authenticator data.  If the sa
            is krb5, this is a KRB_AP_REQ for the same Kerberos principal
            as the webkdc-service token's subject.</t>

            <t hangText='san (string)'>
            <vspace blankLines='0'/>The list of authentication factors
            used by the authenticated user for session authentication, or
            the session authentication factors that are required by this
            WAS for a successful authentication.  This is a list of factor
            codes separated by commas.  For the list of registered factor
            names, see <xref target='factors' />.</t>

            <t hangText='sz (string)'>
            <vspace blankLines='0'/>The authorization subject.  A user (if
            permitted by the WebKDC) may assert an authorization subject in
            addition to their authenticated identity.  If they do so, the
            subject (s) will continue to hold their authenticated identity,
            and this attribute will contain the asserted authorization
            identity.  The WAS may choose whether or not to honor the
            asserted authorization identity.</t>

            <t hangText='t (string)'>
            <vspace blankLines='0'/>The token type.  Currently recognized
            token types are webkdc-service, webkdc-proxy, req, error, id,
            proxy, cred, and app.  Used by a server to ensure that a token
            is being used for the correct purpose.</t>

            <t hangText='u (string)'>
            <vspace blankLines='0'/>The user's username in a login
            token.</t>

            <t hangText='wt (binary)'>
            <vspace blankLines='0'/>A webkdc-proxy or webkdc-service token
            that is being included inside another token.</t>
          </list>
        </t>
      </section>

      <section anchor='factors' title='Authentication Factors'>
        <t>The ia and san attributes contain a comma-separated list of
        authentication factors.  The following are the standardized factor
        names to use and their meaning.  All of these codes are valid for
        both initial authentication and session authentication factor
        lists except where noted.
          <list style='hanging' hangIndent='4'>
            <t hangText='c (cookie)'>
            <vspace blankLines='0'/>Only used for session authentication
            factors, this indicates that the user authenticated this
            session by presenting a cookie containing a webkdc-proxy token
            (rather than, for example, providing a password or other
            credentials).</t>

            <t hangText='d (device)'>
            <vspace blankLines='0'/>The device or browser from which the
            user authenticated is known to the local security
            infrastructure, has previously been part of a successful
            strong authentication, or otherwise is a relatively trusted
            device as defined by local site policy.</t>

            <t hangText='h (human)'>
            <vspace blankLines='0'/>The identity of the user has been
            additionally verified by a human.  This factor is normally not
            requested directly by a WebAuth Application Server, but rather
            is added via some site-specific mechanism by local support
            staff in order to synthesize a multifactor authentication.
            For example, a user may have lost their hardware token but
            need to access a site that requires multifactor.  A WebKDC
            could support some mechanism to add this authentication factor
            and a multifactor factor to the user's next login after the
            user verifies their identity with local support staff via some
            off-line process and then goes through the login proces
            immediately.</t>

            <t hangText='k (Kerberos)'>
            <vspace blankLines='0'/>Only used for session authentication
            factors, this indicates that the user authenticated this
            session using a Kerberos authentication (generally via
            Negotiate-Auth, but possibly via other methods).</t>

            <t hangText='m (multifactor)'>
            <vspace blankLines='0'/>Multiple independent authentication
            factors were used.  The exact requirements for this are
            site-defined, but traditionally means password plus OTP, or
            password plus X.509, or an X.509 authentication from a smart
            card requiring a PIN.</t>

            <t hangText='mp (mobile push)'>
            <vspace blankLines='0'/>The user approved an out-of-band push
            notification to a mobile device as part of the authentication
            process.</t>

            <t hangText='o (OTP)'>
            <vspace blankLines='0'/>Some one-time password method was used
            for authentication.  This factor code is often used in
            combination with one of the o# codes defined below.</t>

            <t hangText='o# (OTP)'>
            <vspace blankLines='0'/>The one-time password method numbered
            # was used.  The meaning of the numbers is site-defined, but
            the numbers should be integers starting with 1 and higher
            numbers should indicate a stronger OTP method.  For example,
            o1 could indicate a printed list of OTP codes, o2 could
            indicate a code sent via SMS message, and o3 could indicate a
            hardware device that is synchronized with the OTP server.</t>

            <t hangText='p (password)'>
            <vspace blankLines='0'/>Traditional password
            authentication.</t>

            <t hangText='rm (random multifactor)'>
            <vspace blankLines='0'/>The user was subject to a random chance
            of being challenged with a requirement for a multifactor
            authentication method and happened not to be challenged.  If
            the user had been challenged, either authentication would have
            failed or the m authentication factor would be used instead.
            The chance of the challenge is site-defined.</t>

            <t hangText='u (unknown)'>
            <vspace blankLines='0'/>The authentication method is not
            known.  This may be used, for example, when the user
            authenticates to the WebLogin component of the WebKDC using
            some authentication mechanism handled external to the WebLogin
            server and no information about that method is available.</t>

            <t hangText='v (voice)'>
            <vspace blankLines='0'/>The user indicated approval of the
            authentication via a callback over voice telephone as part of
            the authentication process.</t>

            <t hangText='x (X.509)'>
            <vspace blankLines='0'/>Some form of X.509 authentication was
            used.  Whether this is via a smart card is site-defined.  This
            factor code is often used in combination with one of the x#
            codes defined below.</t>

            <t hangText='x# (X.509)'>
            <vspace blankLines='0'/>The X.509 authentication method
            numbered # was used.  The meaning of the numbers is
            site-defined, but the numbers should be integers starting with
            1 and higher numbers should indicate a stronger X.509 method.
            For example, x1 could indicate an X.509 certificate that may
            be stored on the file system of a user's system or on a
            removable drive, and x2 could indicate a hardware smart
            card.</t>
          </list>
        </t>

        <t>An authentication factor of m will always satisfy a requirement
        for an authentication factor of rm.</t>

        <t>Implementations may automatically add the m (multifactor)
        factor to the factors for an authentication if factors from more
        than one different authentication method are present (two or more
        from the set of h, mp, o, p, v, and x, for example).  If an
        implementation does this, the c, k, rm, and u factors must not be
        considered when deciding whether to add an m factor.</t>

        <t>Sites may define and use their own factor codes, but they risk
        conflict with future standardized codes unless they coordinate
        that use with this list.</t>
      </section>

      <section anchor='tokenspecific' title='Specific Token Encoding'>
        <t>The following sections describe which tokens are supported,
        what they're used for, and which attributes are included and what
        those attributes mean in that context.</t>

        <section anchor='tokenwebkdcservice' title='webkdc-service Token
          Encoding'>
          <t>webkdc-service tokens are used by WAS servers to communicate
          with the WebKDC.  They are returned by WebKDC after an entity
          authenticates with the WebKDC using the XML interface while
          requesting a service token.</t>

          <figure>
            <preamble>Token format:</preamble>
            <artwork>
  t=webkdc-service
  k={session-key}
  s=krb5:{requesting-servers-k5-principal}
  ct={creation-time}
  et={expiration-time}
            </artwork>
          </figure>

          <t>All attributes are AES-encrypted using the WebKDC's private
          key.  The server that initially requested the token will also
          receive {session-key} and {expiration-time} out-of-band from the
          token itself.  That additional data must also be stored by the
          WAS for the duration of the token.</t>
        </section>

        <section anchor='tokenwebkdcproxy' title='webkdc-proxy Token
          Encoding'>
          <t>A webkdc-proxy token is a proxy authentication token
          maintained by the WebKDC on behalf of another user, or on behalf
          of itself.  Normally it contains a Kerberos credential for the
          ticket-granting service (a Kerberos TGT plus its supporting data
          such as the session key).</t>

          <figure>
            <preamble>Token format:</preamble>
            <artwork>
  t=webkdc-proxy
  ps={subject-from-webkdc-service-token-used-to-get-proxy-token}
  pt=krb5|remuser|...
  s={username}
  [pd={proxy-data}]
  ct={creation-date}
  et={expiration-date}
  [ia={factor-list}]
  [loa={level-of-assurance}]
            </artwork>
          </figure>

          <t>All attributes are AES-encrypted using the WebKDC's private
          key.</t>

          <t>As a special case, krb5 webkdc-proxy tokens that the WebKDC
          obtains on behalf of itself (returned as part of a
          requestTokenRequest, for example) have a ps attribute value of
          WEBKDC:krb5:{server-principal} where {server-principal} is the
          Kerberos principal of the WebKDC.  remuser webkdc-proxy tokens
          (created by WebLogin based on trusting REMOTE_USER
          authentication from the web server rather than via a password
          authentication or forwarded Kerberos ticket) have a ps attribute
          value of WEBKDC:remuser.</t>

          <t>When a webkdc-proxy-token is used in a &lt;getTokensRequest>
          message, the WebKDC checks that the subject in the
          webkdc-service token accompanying the request is authorized to
          used the webkdc-proxy token granted to the ps subject.  When
          used in a &lt;requestTokensRequest>, the WebKDC checks that the
          ps subject starts with "WEBKDC:".</t>
        </section>

        <section anchor='tokenwebkdcfactor' title='webkdc-factor Token
          Encoding'>
          <t>A webkdc-factor token holds additional authentication factors
          that are combined with the factors established with webkdc-proxy
          tokens and login tokens.  A webkdc-factor token by itself is not
          sufficient to authenticate a user, but when combined with other
          tokens can contribute its factors to the authentication factors
          in resulting webkdc-proxy, id, and proxy tokens.</t>

          <t>The primary purpose of webkdc-factor tokens is to store
          additional factors that have a different lifetime than the
          user's authentication credentials.  For example, one might store
          a webkdc-factor token as a long-lived cookie on a particular
          browser that has been vetted in some way and treat subsequent
          authentications where the browser can present that token as
          having an additional authentication factor compared to
          authentications from other browsers.</t>

          <t>webkdc-factor tokens are presented by WebLogin (which would
          normally get them from browser cookies) to the WebKDC as part of
          the &lt;requestTokenRequest> message, and returned to WebLogin
          (to store as browser cookies) as part of the
          &lt;requestTokenResponse> message.</t>

          <figure>
            <preamble>Token format:</preamble>
            <artwork>
  t=webkdc-factor
  s={username}
  ia={factor-list}
  ct={creation-date}
  et={expiration-date}
            </artwork>
          </figure>

          <t>All attributes are AES-encrypted using the WebKDC's private
          key.</t>

          <t>webkdc-factor tokens are only valid when presented in
          conjunction with at least one valid webkdc-proxy or login token
          for the same subject.  Its factors are added to both the initial
          and session factors of a successful authentication.</t>

          <t>Inside the WebKDC, multiple webkdc-factor tokens from
          different sources may be merged into a single token.  If this is
          done, the resulting token's creation and expiration dates should
          be set to the oldest creation and expiration dates of all the
          constituent tokens.  In particular, the creation date of the
          resulting token should not be set to the time at which the
          tokens were merged.  This permits discarding all webkdc-factor
          tokens older than a particular date, which may be a useful
          operation if a particular user experienced a security
          compromise.</t>

          <t>webkdc-factor tokens will contribute their factors to any
          successful authentication until they have expired, even if the
          credentials that result from that authentication will persist
          beyond the expiration time of the webkdc-factor token.  For
          example, one can use a webkdc-factor token that expires in one
          minute as part of an authentication that results in a
          webkdc-proxy token that expires in ten hours, and the
          webkdc-factor token still contributes its factors.  The
          expiration time should therefore be thought of as the time at
          which the webkdc-factor token stops contributing factors to new
          authentications, not the time at which those authentication
          factors fully expire.</t>
        </section>

        <section anchor='tokenrequest' title='request Token Encoding'>
          <t>A request token is sent to the WebKDC server by a WAS along
          with the WAS's webkdc-service token.  It is used to request
          tokens via the HTML interface, and is also used with the XML
          interface (in a restricted form) to allow the WebKDC to verify
          that a request being made with a webkdc-service token is both
          recent and for the specified command.</t>

          <figure>
            <preamble>The first form is used with the requestTokenRequest
            command:</preamble>

            <artwork>
  t=req
  ct={creation-time}
  [as={binary-state-data}]
  ru={return-redirect-url}
  [ro=fa,lc]
  rtt=id|proxy
  # for rt=id
  sa=krb5|webkdc
  # for rt=proxy
  pt=krb5
  [ia={factor-list}]
  [san={factor-list}]
  [loa={level-of-assurance}]
            </artwork>
          </figure>

          <figure>
            <preamble>The second form is used with the getTokensRequest
            command in the XML interface:</preamble>

            <artwork>
  t=req
  ct={creation-time}
  cmd={xml-command-we-are-going-to-execute}
            </artwork>
          </figure>

          <t>All attributes are AES-encrypted using the webkdc-service
          token session key.</t>

          <t>The value of ct is used to prevent replay attacks.  Values
          older than a certain time (probably 5 minutes by default) should
          be rejected as a replay.</t>

          <t>cmd indicates which XML command we are invoking (for example,
          getTokensRequest).  The WebKDC will compare this command against
          the name of the command in the XML, thereby verifying the
          unencrypted XML request.</t>
        </section>

        <section anchor='tokenerror' title='error Token Encoding'>
          <t>An error token is sent from the WebKDC as a response to a
          request token when an error occurs.  It may be returned to the
          WAS as the response token if the user canceled login.</t>

          <figure>
            <preamble>Token format:</preamble>
            <artwork>
  t=error
  ct={creation-time}
  ec={error-code}
  em={error-message}
            </artwork>
          </figure>

          <t>All attributes are AES-encrypted using the webkdc-service token
          session key.</t>

          <t>The value of ct is used to prevent replay attacks.  Values
          older than a certain time (probably 5 minutes by default) should
          be rejected as a replay.</t>
        </section>

        <section anchor='tokenid' title='id Token Encoding'>
          <t>The id token is returned by the WebKDC and is bound to an
          WAS.  It is used to communicate the authenticated identity of a
          user.</t>

          <figure>
            <preamble>Token format:</preamble>
            <artwork>
  t=id
  sa=krb5|webkdc
  # for sa=webkdc
  s={username}
  # for sa=krb5
  sad={result-of-krb5-mk-req-for-webauth/hostname}
  # for any sa
  [sz={authorization-subject}]
  ct={creation-time}
  et={expiration-time}
  [ia={factor-list}]
  [san={factor-list}]
  [loa={level-of-assurance}]
            </artwork>
          </figure>

          <t>All attributes are AES-encrypted using the webkdc-service
          token session key.</t>

          <t>If "at" is krb5, then "sad" (subject authenticator data) is a
          KRB_AP_REQ for the WAS service principal (as determined from the
          subject of the webkdc-service token) using the user's TGT from a
          krb5 webkdc-proxy token.</t>

          <t>If at is webkdc, we are trusting the webkdc and "s" contains
          the authenticated user's identity (generally as a Kerberos
          principal name in text form).</t>

          <t>The value of ct is used to prevent replay attacks.  Values
          older than a certain time (probably 5 minutes by default) should
          be rejected as a replay, as id tokens are only used once and
          re-written into an app token.</t>

          <t>The value of et is used to let the application know how long
          the authentication information in the id token should be
          considered valid for.  The value for et is at latest the
          expiration time of the proxy-token used to create it.</t>
        </section>

        <section anchor='tokenproxy' title='proxy Token Encoding'>
          <t>A proxy token is returned by the WebKDC when a WAS requests a
          proxy token from the WebKDC via the HTML interface.  Normally,
          the WAS just requests an id token directly, but if the WAS may
          need cred tokens for a user, it requests a proxy token instead.
          The proxy token can be later used to retrieve an id or cred
          token from the WebKDC.</t>

          <figure>
            <preamble>Token format:</preamble>
            <artwork>
  t=proxy
  pt=krb5|...
  s={username}
  [sz={authorization-subject}]
  wt={webkdc-proxy-token}
  ct={creation-time}
  et={expiration-time}
  [ia={factor-list}]
  [san={factor-list}]
  [loa={level-of-assurance}]
            </artwork>
          </figure>

          <t>All attributes are AES-encrypted using the webkdc-service
          token session key.</t>

          <t>In addition to the webkdc-proxy token, a proxy token provides
          all the same authentication information about a user as an id
          token with a subject auth of "webkdc".  If the WAS only needs id
          token information at the level provided by the "webkdc" subject
          auth type, it can use the proxy token for that information
          without requesting an id token.  If it wants an id token with a
          "krb5" subject auth type, it will have to request that from the
          WebKDC using the proxy token.</t>

          <t>The value of ct is used to prevent replay attacks.  Values
          older then a certain time (probably 5 minutes by default) should
          be rejected as a replay, as proxy tokens are only used once and
          re-written into an app token.</t>

          <t>wt is the webkdc-proxy token (in binary form).  It can be
          used by the WAS later to request credential tokens from the
          WebKDC.</t>

          <t>Note that the authorization subject included in the proxy
          token will not be reflected in any id tokens obtained via the
          proxy token.  The id tokens will be based on the webkdc-proxy
          token, which is for the authentication identity alone.
          Therefore, a WebAuth Application Server that wants to use the
          authorization identity in some way needs to note the
          authorization subject from the proxy token and not rely on
          getting it from any subsequent id token.  Similarly, any cred
          tokens obtained from a proxy token will be for the
          authentication identity, not the authorization identity.</t>
        </section>

        <section anchor='tokencred' title='credential Token Encoding'>
          <t>A credential token is an authentication credential for the
          user for some other service, used by the WAS for proxied
          authentication.  It is normally a Kerberos service ticket
          generated by the WebKDC from the user's TGT.</t>

          <figure>
            <preamble>Token format:</preamble>
            <artwork>
  t=cred
  crs={server-principal}
  crt=krb5|...
  s={username}
  cd={credential-data}
  ct={creation-date}
  et={expiration-date}
            </artwork>
          </figure>

          <t>All attributes are AES-encrypted using the webkdc-service
          token session key.</t>
        </section>

        <section anchor='tokenlogin' title='login Token Encoding'>
          <t>A login token is used by the WebLogin component of the WebKDC
          to communicate an authentication request to the WebKDC.  This
          always contains a username, and may contain a password,
          one-time password (OTP), or device identifier to use for
          authetnication.</t>

          <figure>
            <preamble>Token format:</preamble>
            <artwork>
  t=login
  ct={creation-time}
  u={username}
  [p={password}]
  [otp={one-time-password-code}]
  [ott={one-time-password-factor}]
  [did={device-id}]
            </artwork>
          </figure>

          <t>All attributes are AES-encrypted using the WebKDC's private
          key.  One of p, otp, or did must be provided.  If otp is
          provided, did and ott may also be provided (but are not required
          by the WebAuth protocol, although they may be required by local
          site configuration).  did should be a device ID chosen from the
          device attributes of &lt;configuredFactor> tags in the
          &lt;requestTokenResponse> reply.  ott should be a factor code
          (generally one of the oN factors) indicating what type of OTP
          this code is for, or a factor code indicating what type of
          authentication to attempt with this device.</t>
        </section>

        <section anchor='tokenapp' title='app Token Encoding'>
          <t>An app token is controlled and maintained by a WAS.  The main
          use of an app token is to cache the idenity within an id token
          after it has been verified.</t>

          <figure>
            <preamble>Token format:</preamble>
            <artwork>
  t=app
  et={expiration-time}
  [ct={creation-time}]
  [s={username}]
  [sz={authorization-subject}]
  [k=session-key]
  [lt={last-use-time}]
  [ia={factor-list}]
  [san={factor-list}]
  [loa={level-of-assurance}]
            </artwork>
          </figure>

          <t>All attributes are AES-encrypted using the WAS's private
          key.</t>

          <t>app tokens are normally created on first receipt of an id
          token.   After the id token is verified, it is converted into an
          app token and then stored in a cookie.</t>

          <t>{last-use-time} is optional and should only be included if
          the WAS wishes to invalidate idle but unexpired app tokens.</t>

          <t>{session-key} is only present when an app token is being used
          as the application state inside of a request token.  This is
          done when serving the same web resource with a pool of servers
          that all should be able to decrypt the id token from the
          WebKDC.</t>
        </section>
      </section>

      <section anchor='krb5token' title='Kerberos Credential Encoding'>
        <t>Kerberos credentials may be included in several types of
        WebAuth tokens.  Whenever this is done, the credential data is
        encoded using the same basic encoding format as a token, and the
        system receiving the credential must decode it and recreate the
        Kerberos credential structure to use it.  This allows
        interoperability between different platforms and different
        Kerberos implementations.</t>

        <t>The credential encoding uses the following attributes, where
        binary number is a 32-bit number in network byte order and binary
        time is a 32-bit time in seconds since 1970-01-01 00:00:00
        UTC:
          <list style='hanging' hangIndent='4'>
            <t hangText='c (string)'>
            <vspace blankLines='0'/>Client principal name.</t>

            <t hangText='s (string)'>
            <vspace blankLines='0'/>Server principal name.</t>

            <t hangText='K (binary number)'>
            <vspace blankLines='0'/>Kerberos encryption type for the
            session key.  This will be whatever numerical constant is used
            by Kerberos for that encryption type.</t>

            <t hangText='k (binary)'>
            <vspace blankLines='0'/>Kerberos session key.</t>

            <t hangText='ta (binary time)'>
            <vspace blankLines='0'/>Authentication time of the
            credential.</t>

            <t hangText='ts (binary time)'>
            <vspace blankLines='0'/>Start time of the credential (the time
            at which the credential becomes valid).</t>

            <t hangText='te (binary time)'>
            <vspace blankLines='0'/>Expiration time of the credential,
            after which it is no longer valid.</t>

            <t hangText='tr (binary time)'>
            <vspace blankLines='0'/>Renewal end time of the credential.
            The credential may be renewed up until this time.</t>

            <t hangText='i (binary)'>
            <vspace blankLines='0'/>Flag set to 0 or 1 indicating whether
            the credential was obtained via S/Key.  This attribute should
            probably always be 0 or not provided; it is not supported at
            all by Heimdal.</t>

            <t hangText='f (binary number)'>
            <vspace blankLines='0'/>The ticket flags.  This is a 32-bit
            bitmask of Kerberos ticket flags, as defined by the Kerberos
            protocol specification.</t>

            <t hangText='na (binary number)'>
            <vspace blankLines='0'/>The number of addresses associated
            with the credential.  Address checking on credentials is
            generally not useful for WebAuth, so it might be best to
            always skip including this in the credential, but space is
            provided in case it's useful for some reason.  For each
            address, there is a corresponding "A" attribute holding the
            address type and an "a" attribute holding the address
            itself.</t>

            <t hangText='A# (binary number)'>
            <vspace blankLines='0'/>The type of address for the #th
            address.  # is replaced by the index number of the address.
            Addresses are numbered starting with 0, so if na was 2, there
            will be an A0 attribute and an A1 attribute (but no A2
            attribute).</t>

            <t hangText='a# (binary)'>
            <vspace blankLines='0'/>The #th address in the credential.  #
            is replaced by the index number of the address.  Addresses are
            numbered starting with 0, so if na was 2, there will be an a0
            attribute and an a1 attribute (but no a2 attribute).</t>

            <t hangText='t (binary)'>
            <vspace blankLines='0'/>The Kerberos ticket.</t>

            <t hangText='t2 (binary)'>
            <vspace blankLines='0'/>The second Kerberos ticket in the
            credentials, if any.</t>

            <t hangText='nd (binary number)'>
            <vspace blankLines='0'/>The number of authenticatation data
            blocks in the credential.  For each data block, there is a
            corresponding "D" attribute holding the data type and a "d"
            attribute holding the data block itself.</t>

            <t hangText='D# (binary number)'>
            <vspace blankLines='0'/>The type of authentication data for
            the #th data block.  # is replaced by the index number of the
            data block.  Data blocks are numbered starting with 0, so if
            nd was 2, there will be a D0 attribute and a D1 attribute (but
            no D2 attribute).</t>

            <t hangText='d# (binary number)'>
            <vspace blankLines='0'/>The #th authentication data block.  #
            is replaced by the index number of the block.  Data blocks are
            numbered starting with 0, so if nd was 2, there will be a d0
            attribute and a d1 attribute (but no d2 attribute).</t>
          </list>
        </t>
      </section>
    </section>

    <section anchor='cookies' title='Cookie Formats'>
      <t>Cookies are used to hold tokens in a UA for future use.  All
      cookies MUST be scoped to a single server; there are no domain-wide
      cookies.  All cookies will be encoded in base64 before passing them
      to the UA.</t>

      <t>The tokens that are put in cookies are webkdc-proxy, proxy, app,
      and cred tokens.  The following naming convention will be used to
      name cookies.</t>

      <t>Note that proxy tokens and credential tokens are originally
      encrypted with the webkdc-service token session key, but are
      re-encrypted using the WAS private key before being stored in a
      cookie.</t>

      <t>app token cookies will be named webauth_at.</t>

      <t>webkdc-proxy token cookies will be named webauth_wpt_{type} where
      {type} is the type of the webkdc-proxy token (usually krb5).</t>

      <t>webkdc-factor token cookies will be named webkdc_wft.  This means
      that only a single factor token cookie can be set within a
      particular browser.  If there are multiple sources of factors that
      should be stored in webkdc-factor tokens, they must be merged into a
      single token by the WebKDC.</t>

      <t>proxy token cookies will be named webauth_pt_{type} where {type}
      is the type of the proxy token (usually krb5).</t>

      <t>credential tokens will be named webauth_ct_{type}_{service} where
      {type} is the type of the credential token (usually krb5) and
      {service} is the krb5 service name, potentially with special
      characters escaped.</t>
    </section>
  </middle>

  <back>
    <section anchor='history' title='Document Revision History'>
      <t>
        <list style='hanging' hangIndent='4'>
          <t hangText='1.01 (2002-12-12, schemers)'>
          <vspace blankLines='0'/>Keys in the keyring no longer expire.
          The key with the most current (but not post-dated) valid_after
          will always be used to encrypt new keys.</t>

          <t hangText='1.02 (2003-01-14, schemers)'>
          <vspace blankLines='0'/>Return &lt;subject> in &lt;requestToken>
          response so the web front-end can display the authenticated
          username.</t>

          <t hangText='1.03 (2003-01-20, schemers)'>
          <vspace blankLines='0'/>Fix type in credential token coding
          example: change ct to crt.  Add crs attribute to credential
          token.</t>

          <t hangText='1.04 (2003-01-29, schemers)'>
          <vspace blankLines='0'/>When appending WEBAUTHR to return URL,
          use "?WEBAUTHR=...;" instead of ";WEBAUTHR=...;" so browers
          handle relative URLs correctly.</t>

          <t hangText='1.05 (2003-07-24, schemers)'>
          <vspace blankLines='0'/>Add webkdcProxyToken and
          webkdcProxyTokenInfo commands.  Added requestInfo to
          requestToken command for S/Ident support.</t>

          <t hangText='2.0.0 (2006-01-02, rra)'>
          <vspace blankLines='0'/>Rewritten in XML and substantially
          edited, clarified, and reworked.  Added &lt;remoteUser> to
          &lt;requestInfo> and clarified that &lt;requestInfo> must be
          used only for logging and auditing now that we're not trying to
          do S/Ident any more.  Don't assume Kerberos in the first
          descriptions of protocol elements.  Add text explaining why one
          may not have a webkdc-proxy token with other forms of
          authentication.</t>

          <t hangText='2.0.1 (2006-01-23, rra)'>
          <vspace blankLines='0'/>Move the document history into an
          appendix.  Document the magic WEBKDC prefix to proxy
          subjects.</t>

          <t hangText='2.1.0 (2006-02-17, rra)'>
          <vspace blankLines='0'/>Add a specification for the encoding of
          Kerberos credentials in tokens.  Specify the size of
          timestamps.</t>

          <t hangText='2.1.1 (2008-03-14, rra)'>
          <vspace blankLines='0'/>Add error code 18, indicating that the
          WebKDC did not permit the user's principal to authenticate.  Fix
          typo in the webkdcProxyTokenInfoRequest example.  Fix XML
          formatting issues.</t>

          <t hangText='2.1.2 (2009-06-24, rra)'>
          <vspace blankLines='0'/>Add requestedTokenType to the XML
          returned in response to &lt;requestToken> so that the WebLogin
          component can make decisions based on whether the WAS requested
          an id token or a proxy token.</t>

          <t hangText='2.1.3 (2010-05-15, rra)'>
          <vspace blankLines='0'/>Replace all mentions of krb5_mk_req with
          KRB_AP_REQ, which is the correct protocol term for the results
          of a krb5_mk_req call.</t>

          <t hangText='3.0.0 (2011-07-22, rra)'>
          <vspace blankLines='0'/>Add ia, san, and loa attributes to
          various tokens to store authentication factor information and
          level of assurance.  Document the factor codes for
          authentication factors.  Remove &lt;messageId> and
          &lt;protocolVersion> from the XML specification; neither were
          ever implemented.  Add additional error codes for multifactor
          and Level of Assurance support.  Add &lt;multifactorRequired>
          and &lt;loginHistory> to &lt;requestTokenResponse> and the otp
          attribute to the login token.  Remove the type attribute to
          &lt;subjectCredential> and change the protocol to allow both
          &lt;proxyToken> and &lt;loginToken> to be sent in the same
          request.  Add the type attribute to &lt;proxyToken>.  Include
          source factor information in &lt;proxyToken> elements sent to
          the WebKDC, used to derive session factor information.</t>

          <t hangText='3.1.0 (2011-09-21, rra)'>
          <vspace blankLines='0'/>Change the &lt;loginHistory> XML schema
          to have the content of &lt;loginLocation be the IP address.  The
          hostname is now an optional attribute.</t>

          <t hangText='3.2.0 (2012-07-17, rra)'>
          <vspace blankLines='0'/>Add error code 24, representing a rejected
          authentication, and add optional element &lt;userMessage&gt; to
          &lt;requestTokenResponse&gt;.</t>

          <t hangText='3.2.1 (2012-09-07, rra)'>
          <vspace blankLines='0'/>Clarify references to a "Kerberos TGT",
          which normally mean a Kerberos credential that includes the TGT
          plus other supporting data such as the session key.  Replace
          remaining K5 references with just Kerberos.</t>

          <t hangText='3.3.0 (2012-11-20, rra)'>
          <vspace blankLines='0'/>Add &lt;authzSubject&gt; to
          &lt;requestTokenRequest&gt; and &lt;requestTokenResponse&gt; to
          allow requesting and returning authorization identities.  Add
          &lt;permittedAuthzSubjects&gt; to &lt;requestTokenResponse&gt;
          to tell WebLogin what authorization identities the user may
          assert.  Add the sz attribute to app, id, and proxy tokens to
          hold the asserted authorization identity.  Clarify that attribute
          names are alphanumeric.</t>

          <t hangText='3.3.1 (2012-12-06, rra)'>
          <vspace blankLines='0'/>Add error code 25, representing an
          authentication that appears to be a replay, and error code 26,
          indicating a rejected authentication due to too many failed
          authentication attempts for this user.</t>

          <t hangText='3.4.0 (2013-02-04, rra)'>
          <vspace blankLines='0'/>Add the webkdc-factor token type, the
          &lt;factorToken> element to the &lt;requestTokenRequest> API,
          &lt;factorTokens> element to the &lt;requestTokenResponse> API,
          and the d factor.</t>

          <t hangText='3.5.0 (2013-04-02, rra)'>
          <vspace blankLines='0'/>Clarify the two cases for a
          &lt;getTokenRequest> and remove the ability to request proxy
          tokens.  Clarify the proxy subject checking in the webkdc-proxy
          token encoding description.  Include the expiration time of a
          factor token in the &lt;requestTokenResponse&gt; response as an
          attribute on the &lt;factorToken&gt; element.  Clarify that the
          webkdc-factor expiration time reflects when it stops
          contributing factors to new authentications, not when those
          factors go away entirely.  Add the ott attribute to the login
          token, which conveys the type of OTP that the code is for.  Add
          the h factor.  Clarify that error code 14 can be used for a wide
          variety of login failures.  Clarify differences between error
          codes 22, 24, and 26.</t>

          <t hangText='3.5.1 (2013-09-26, rra)'>
          <vspace blankLines='0'/>Be explicit that token encryption is
          128-bit AES in CBC mode.</t>

          <t hangText='3.5.2 (2013-11-09, rra)'>
          <vspace blankLines='0'/>Document the IV used for token
          encryption and be explicit about the security requirements for
          nonces and key rotation.</t>

          <t hangText='3.6.0 (2014-07-10, rra)'>
          <vspace blankLines='0'/>Add attributes for &lt;configuredFactor>
          tags in &lt;requestTokenResponse> to provide WebLogin with more
          information about possible factors.  Add the did token attribute
          to login tokens to communicate the ID of the device with which
          the user is attempting to authenticate.  Add new mp and v factor
          codes.  Wording and grammar clarifications, thanks to Adam
          Lewenberg.</t>

          <t hangText='3.6.1 (2014-08-13, rra)'>
          <vspace blankLines='0'/>Add new elements &lt;defaultFactor> and
          &lt;devices> in &lt;requestTokenResponse> to provide WebLogin
          with more information about possible factors and authentication
          methods.  Remove the attributes for &lt;configuredFactor> tags,
          since that approach was less flexible.</t>

          <t hangText='3.7.0 (2014-09-18, jonrober)'>
          <vspace blankLines='0'/>Add error code 27, representing a
          remctl timeout during multifactor login.</t>
        </list>
      </t>
    </section>

    <section anchor='license' title='License'>
      <t>Copyright 2006, 2008, 2009, 2010, 2011, 2012, 2013, 2014 The
      Board of Trustees of the Leland Stanford Junior University</t>

      <t>Copying and distribution of this file, with or without
      modification, are permitted in any medium without royalty provided
      the copyright notice and this notice are preserved.  This file is
      offered as-is, without any warranty.</t>
    </section>
  </back>
</rfc>
